# B-Tree 인덱스

데이터베이스에서 가장 일반적으로 사용되고 가장 먼저 도입된 알고리즘

- 일반적으로 B+-Tree, B\*-Tree가 사용된다.
- B는 Binary 가 아닌 Balanced 를 의미한다.

## 구조 및 특성

최상위에 하나의 '루트 노드(Root Node)'가 존재하고 하위에 자식 노드가 붙어 있는 형태 <br />
리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.

> 대부분의 RDBMS의 데이터 파일에서 레코드는 특정 기준으로 정렬되지 않고 임의의 순서로 저장된다. <br />
> InnoDB 테이블에서 레코드는 클러스터되어 기본적으로 프라이머리 키 순서로 정렬되어 저장된다. <br />
> 다른 DBMS 에서 클러스터링 기능이 선택사항이지만 InnoDB에서는 디폴트로 클러스터링 테이블이 생성된다. <br />

InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못하고 <br />
프라이머리 키 값을 이용하여 한 번 더 검색한 후, 프라이머리 키 인덱스 리프 페이지에 저장되어 있는 레코드를 읽는다.

## B-Tree 인덱스 키 추가, 삭제

### 인덱스 키 추가

1. 저장될 키 값을 이용해 트리상의 적절한 위치를 검색해야 한다.
2. 레코드의 키 값과 대상 레코드의 주소 정보를 트리의 리프노드에 저장한다.
3. 리프 노드가 꽉 차서 저장할 수 없는 경우 리프 노드가 분리되어야 한다. <br />
   상위 브랜치 노드까지 처리 범위가 넓어지는데 이로 인해 상대적으로 쓰기 작ㅇ버에 비용이 많이 든다.

> 대략적으로 인덱스 추가로 인한 영향을 계산하는 방법은 테이블에 칼럼 수, 칼럼의 크기, 인덱스 칼럼의 특성 등을 확인해야 한다. <br />
> 레코드를 추가하는 작업 비용을 1이라고 하면 해당 테이블의 인덱스에 키를 추가하는 작업 비용을 1.5 정도로 예측한다. <br />
> 중요한 것은 비용의 대부분이 메모리와 CPU에서 처리하는 시간이 아닌 디스크로부터 인덱스를 읽고 쓰기를 하는 시간까지 포함한다.

### 인덱스 키 삭제

해당 키가 저장된 B-Tree의 리프노드를 찾아 삭제 마크만 하면 작업이 완료된다. <br />
삭제 마킹된 인덱스 키 공간은 그대로 방치하거나 재활용할 수 있다.

- 인덱스 키 삭제의 마킹 작업 또한 디스크 쓰기가 필요한 I/O 작업이다.

### 인덱스 키 변경

인덱스의 키 값에 따라 저장될 리프 노드의 위치가 결정되므로 인덱스 상의 키 값만 변경하는 것은 불가능하다. <br />
먼저 키 값을 삭제한 다음, 다시 새로운 키 값을 추가하는 형태로 처리된다.

### 인덱스 키 겁색

루트 노드부터 시작하여 최종 리프 노드까지 이동하면서 비교 작업을 수행한다. <br />

- 트리 탐색이라고 한다.
- Update, Delete 하는 경우 해당 레코드를 먼저 찾을 경우에도 사용된다.
- 100% 일치 혹은 값의 앞부분만 일치하는 경우 사용할 수 있다.
  - 키 값의 뒷부분만 검색하는 경우는 불가능하다.
- 부등호 비교 조건에서도 활용할 수 있다.

> 인덱스의 키 값에 변형이 가해진 후 비교되는 경우엔 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다. <br />
> 이미 변형된 값은 B-Tree 인덱스에 존재하는 값이 아니다.

InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현 되어 있다. <br />
UPDATE 나 DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.

## B-Tree 인덱스 사용에 영향을 미치는 요소
